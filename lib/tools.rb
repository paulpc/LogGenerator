  # will generate a mind map of the current environment
   
  class File
    # open_mm is a File.open on steroids. It opens the mind map file and writes the begining and end tags as well as the comment with the program writing this mindmap
    def self.open_mm(*args)
      io=File.open(*args)
      io.write("<map version=\"mm0.1\">\n")
      io.write("<!-- Mind Map generated by the mindmap ruby gem -->")
      yield io
      io.write("</map>\n")
      io.close()
    end
  
    # the options couls include everything you would use in a mindmap node. Common ones are:
    # => Font options: :font_name, :font_size, :font_bold, :font_italic
    # => Icon options: ["help","messagebox_warning","idea","button_ok","button_cancel","full-1","full-2","full-3","full-4","full-5","full-6","full-7","back",
    # =>  => "forward","attach",,"ksmiletris","clanbomber","desktop_new","flag","gohome","kaddressbook","knotify","korn","Mail","password","pencil","stop","wizard","xmag",
    # =>  => "bell","bookmark","penguin","licq"]
    # => Cloud options: :cloud (generic option to draw a cloud around the node), :cloud_color (the color for the cloud)
    # => node options: :text, :collapsed, :color (html format), :background_color (html format), <edge COLOR="#66ff00" WIDTH="4"/>
    def node(options={})
      parameters=[]
      font={}
      edge={}
      cloud=nil
      icons=[]
      options.each {|option,value|
        if option==:icon
          value.each {|icon|
            icons.push("<icon BUILTIN=\"#{icon}\"/>")
          }
        elsif [:font_size,:font_name,:font_bold,:font_italic,].include?(option)
          font[option.to_s.sub(/font_/,"")]=value
        elsif option==:cloud
          cloud={}
        elsif [:cloud_color].include?(option)
          cloud={} unless cloud
          cloud[option.to_s.sub(/cloud_/,"")]=value
        elsif [:edge_width,:edge_color,:edge_style].include?(option)
          edge[option.to_s.sub(/edge_/,"")]=value
        else
          parameters.push("#{option.to_s.upcase}=\"#{value}\"")  
        end
      }
      if block_given? or not font.empty? or not icons.empty? or (cloud and not cloud.empy?) or not edge.empty?
        self.write("<node CREATED=\"#{Time.now.to_i}#{rand(899)+100}\" ID=\"scenario_#{options[:text].gsub(/[\.\ ]/,"_")}#{rand(3000)}\" MODIFIED=\"#{Time.now.to_i}#{rand(999)}\" #{parameters.join(" ")}>\n")
        unless edge.empty?
          self.write("<edge ")
          edge.each {|option,value|
            self.write("#{option.upcase}=\"#{value}\" ")
          }
          self.write("/>\n")
        end
        self.write icons.join("\n")+"\n" unless icons.empty?
        if cloud
          self.write("<cloud ")
          cloud.each {|option,value|
            self.write("#{option.upcase}=\"#{value}\" ")
          }
          self.write("/>\n")
        end
        unless font.empty?
          self.write("<font ")      
          font.each {|option,value|
            self.write("#{option.upcase}=\"#{value}\" ")
          }
          self.write "NAME=\"SansSerif\" "unless font[:name]
          self.write "SIZE=\"12\"" unless font[:size]
          self.write("/>\n")
        end
        yield self if block_given?
        self.write("</node>")
      else
        self.write("<node CREATED=\"#{Time.now.to_i}#{rand(899)+100}\" ID=\"scenario_#{options[:text].gsub(/[\.\ ]/,"_")}#{rand(3000)}\" MODIFIED=\"#{Time.now.to_i}#{rand(999)}\"  #{parameters.join(" ")}\/>\n")
      end
    end
    
  end
  
  def take_snapshot()
    @snapshots=[] unless @snapshots
    @snapshot.push({:domain_name=>$domain_name,:users=>$directory,:servers=>$servers, :firewall=>$firewall})
  end
  
  def diff()
    
  end
  
  def generate_mind_map(filename="./output/mm/scenario_start.mm")
    colors={"Sources::Apache"=>"#A0A2F4", "Sources::Syslog"=>"#FFFF7F","Sources::Mail"=>"#4EFF4E", :fw_rule=>"#77EEAA","Sources::BluecoatSG"=>"#23A5FF" ,:users=>["FFBBED", "FFBBC8", "FFBBBB", "FFBB9F", "FFBB7A", "FFBB5A", "FFBB3F", "FF7AFF", "FF7AED", "FF7AC8", "FF7ABB", "FF7A9F", "FF7A7A","FF7A3F","FF7FFF", "FF7FF3", "FF7FDA", "FF7FD2", "FF7FBF", "FF7FA6", "FF7F91", "FF7F7F", "C8FFFF", "C8FFED", "C8FFC8", "C8FFBB", "C8FF9F", "C8FF7A", "C8FF5A", "C8FF3F", "9FFFFF", "9FFFED", "9FFFC8", "9FFFBB", "9FFF9F", "9FFF7A", "9FFF5A", "9FFF3F", "FFC8FF", "EDC8FF", "C8C8FF", "BBC8FF", "9FC8FF", "7AC8FF", "5AC8FF", "3FC8FF"]}
    @filename=filename
    File.open_mm(@filename,"w") {|mm|
      mm.node(:text=>$domain_name,:color=>"#1CCD92") {|base_node|
        base_node.node(:text=>"Users",:position=>"right") {|users_base_node|
          $directory.each {|user,groups|
            users_base_node.node(:text=>user,:icon=>["ksmiletris"],:cloud=>true,:cloud_color=>"##{colors[:users].sample}") {|user_node| #)
              # write down groups
              user_node.node(:text=>"Groups") {|groups_node|
                groups.each {|group|
                  groups_node.node(:text=>group)
                }
              }
              # put down the email address:
              user_node.node(:text=>"Email") {|mail_node|
                mail_node.node(:text=>$servers[:email].email_directory[user])
              }
              # put down the machine the user is using
              user_node.node(:text=>"Computer") {|computer_node|
                computer_node.node(:text=>$userbase[user].host)
                computer_node.node(:text=>$userbase[user].ip)
              }
        
            }
        
          }
            
        }
        # generate list of servers
        base_node.node(:text=>"Servers",:position=>"left") {|servers_base_node|
          $servers.each {|name,server|
            icons=[]
            icons.push("gohome") if server.class == Sources::Apache
            icons.push("Mail") if server.class == Sources::Mail
            icons.push("penguin") if server.class == Sources::Syslog or server.class == Sources::Apache or server.class == Sources::Mail
            icons.push("stop") if server.class == Sources::BluecoatSG
            servers_base_node.node(:text=>name.to_s,:icon=>icons,:cloud=>true,:cloud_color=>"#{colors[server.class.to_s]}") {|server_node| #
              server_node.node(:text=>server.host)
              server_node.node(:text=>server.ip)
              server_node.node(:text=>server.class.to_s)
              # looking for local accounts
              if defined?(server.shadow) and server.shadow and not server.shadow.empty?
                server_node.node(:text=>"Local Accounts") {|shadow_node|
                  server.shadow.keys.each {|account|
                    shadow_node.node(:text=>account)
                  }
                }
              end
              # looking for local groups
              if defined?(server.etc_group) and server.etc_group and not server.etc_group.empty?
                server_node.node(:text=>"Local Groups") {|group_node|
                  server.etc_group.values.each {|etc_group|
                    group_node.node(:text=>etc_group)
                  }
                }
              end
              if server.class == Sources::Apache
                server_node.node(:text=>"sitemap") {|sitemap_node|
                  server.structure.each {|page|
                    sitemap_node.node(:text=>page)
                  }
                }
              elsif server.class == Sources::BluecoatSG
                server_node.node(:text=>"categories",:folded=>"true") {|categories_node|
                  server.categories.keys.each {|cat_key|
                    categories_node.node(:text=>cat_key)
                  }
                }
                  
                server_node.node(:text=>"blacklist", :collapsed=>"true") {|blacklist_node|
                  server.blacklist.each {|group,cat|
                    blacklist_node.node(:text=>group){|bl_node|
                      cat.each{|c| bl_node.node(:text=>c)}                        
                    }
                  }
                }
              end
            }
          }      
        }
        #firewall settings
        base_node.node(:text=>$firewall.host,:position=>"left", :icon=>["Key"])  {|firewall_node|
          firewall_node.node(:text=>$firewall.ip)
          firewall_node.node(:text=>"Zones") {|zones_node|
            $firewall.zones.each {|zone,range|
              zones_node.node(:text=>zone.to_s) {|zone_node|
                zone_node.node(:text=>range,:edge_style=>"linear")
              }
            }
          }
          firewall_node.node(:text=>"Rules") {|rules_node|
            $firewall.rule_set.each {|id,from,to,services|
              rules_node.node(:text=>id.to_s,:cloud=>true, :cloud_color=>colors[:fw_rule]) {|irule_node|
                # source
                irule_node.node(:text=>"source") {|source_node|
                  from.each{|source| source_node.node(:text=>source)}  
                }
                # destination
                irule_node.node(:text=>"destination") {|destination_node|
                  to.each {|dest| destination_node.node(:text=>dest)}
                }
                # services
                irule_node.node(:text=>"service") {|services_node|
                  services.each {|svc| services_node.node(:text=>svc)}
                }
              }
            }
        
          }
        }
      }
    }
  end

