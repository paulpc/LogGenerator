  # will generate a mind map of the current environment
   
  class File
    # open_mm is a File.open on steroids. It opens the mind map file and writes the begining and end tags as well as the comment with the program writing this mindmap
    def self.open_mm(*args)
      io=File.open(*args)
      io.write("<map version=\"mm0.1\">\n")
      io.write("<!-- Mind Map generated by the mindmap ruby gem -->\n")
      yield io
      io.write("</map>\n")
      io.close()
    end
  
    # the options couls include everything you would use in a mindmap node. Common ones are:
    # => Font options: :font_name, :font_size, :font_bold, :font_italic
    # => Icon options: ["help","messagebox_warning","idea","button_ok","button_cancel","full-1","full-2","full-3","full-4","full-5","full-6","full-7","back",
    # =>  => "forward","attach",,"ksmiletris","clanbomber","desktop_new","flag","gohome","kaddressbook","knotify","korn","Mail","password","pencil","stop","wizard","xmag",
    # =>  => "bell","bookmark","penguin","licq"]
    # => Cloud options: :cloud (generic option to draw a cloud around the node), :cloud_color (the color for the cloud)
    # => node options: :text, :collapsed, :color (html format), :background_color (html format)
    def node(options={})
      parameters=[]
      font={}
      edge={}
      cloud=nil
      icons=[]
      options.each {|option,value|
        if option==:icon
          value.each {|icon|
            icons.push("#{" ".rjust($spaces+2," ")}<icon BUILTIN=\"#{icon}\"/>")
          }
        elsif [:font_size,:font_name,:font_bold,:font_italic,].include?(option)
          font[option.to_s.sub(/font_/,"")]=value
        elsif option==:cloud
          cloud={}
        elsif [:cloud_color].include?(option)
          cloud={} unless cloud
          cloud[option.to_s.sub(/cloud_/,"")]=value
        elsif [:edge_width,:edge_color,:edge_style].include?(option)
          edge[option.to_s.sub(/edge_/,"")]=value
        else
          parameters.push("#{option.to_s.upcase}=\"#{value}\"")  
        end
      }
      if block_given? or not font.empty? or not icons.empty? or (cloud and not cloud.empy?) or not edge.empty?
        self.write("#{' '.rjust($spaces," ")}<node CREATED=\"#{Time.now.to_i}#{rand(899)+100}\" ID=\"scenario_#{options[:text].gsub(/[\.\ ]/,"_")}#{rand(3000)}\" MODIFIED=\"#{Time.now.to_i}#{rand(999)}\" #{parameters.join(" ")}>\n")
        $spaces+=2
        unless edge.empty?
          self.write("#{" ".rjust($spaces," ")}<edge ")
          edge.each {|option,value|
            self.write("#{option.upcase}=\"#{value}\" ")
          }
          self.write("/>\n")
        end
        self.write icons.join("\n")+"\n" unless icons.empty?
        if cloud
          self.write("#{" ".rjust($spaces," ")}<cloud ")
          cloud.each {|option,value|
            self.write("#{option.upcase}=\"#{value}\" ")
          }
          self.write("/>\n")
        end
        unless font.empty?
          self.write("#{" ".rjust($spaces," ")}<font ")      
          font.each {|option,value|
            self.write("#{option.upcase}=\"#{value}\" ")
          }
          self.write "NAME=\"SansSerif\" "unless font[:name]
          self.write "SIZE=\"12\"" unless font[:size]
          self.write("/>\n")
        end
        yield self if block_given?
        $spaces-=2
        self.write("#{" ".rjust($spaces," ")}</node>\n")
      else
        self.write("#{" ".rjust($spaces," ")}<node CREATED=\"#{Time.now.to_i}#{rand(899)+100}\" ID=\"scenario_#{options[:text].gsub(/[\.\ ]/,"_")}#{rand(3000)}\" MODIFIED=\"#{Time.now.to_i}#{rand(999)}\"  #{parameters.join(" ")}\/>\n")
      end
    end
    
  end
  
  def take_snapshot()
    @snapshot=[] unless @snapshot
    @snapshot.push({:domain_name=>$domain_name,:users=>$directory,:userbase =>$userbase,:servers=>$servers, :firewall=>$firewall})
  end

  def group_color(group)
    gr_col={}
    File.open( './config/groups_colors.yml' ) { |yf| gr_col=YAML::load( yf ) }
    return "##{gr_col[group].to_a.first || "DDDDDD"}"
  end
  
  def classify_firewall_zone(zone)
    result={}
    case zone.to_s
    when "mail_servers"
      result[:cloud_color]="##{@colors["Sources::Mail"].first}"
      result[:icons]=@colors["Sources::Mail"].last
    when "Trust"
      result[:cloud_color]="##{@colors["Sources::Windows"].first}"
      result[:icons]=@colors["Sources::Windows"].last
    when "public_gateway"
      result[:cloud_color]="##{@colors["Sources::Firewall"].first}"
      result[:icons]=@colors["Sources::Firewall"].last
    when "web_servers"
      result[:cloud_color]="##{@colors["Sources::Apache"].first}"
      result[:icons]=@colors["Sources::Apache"].last
    when "firewalls"
      result[:cloud_color]="##{@colors["Sources::Firewall"].first}"
      result[:icons]=@colors["Sources::Firewall"].last
    else
      result[:cloud_color]="##{@colors["Sources::Syslog"].first}"
      result[:icons]=["pencil"]
    end
    return result
  end
  
  def draw_firewall(base,diff=false)
     base.node(:text=>@snapshot.last[:firewall].host,:position=>"left", :icon=>@colors["Sources::Firewall"].last, :cloud_color=>"##{@colors["Sources::Firewall"].first}")  {|firewall_node|
          firewall_node.node(:text=>@snapshot.last[:firewall].ip)
          firewall_node.node(:text=>"Zones") {|zones_node|
            @snapshot.last[:firewall].zones.each {|zone,range|
              appearance=classify_firewall_zone(zone.to_s)
              zones_node.node(:text=>zone.to_s,:cloud=>true,:cloud_color=>appearance[:cloud_color],:icon=>appearance[:icons]) {|zone_node|
                zone_node.node(:text=>range,:edge_style=>"linear")
              }
            }
          }
          firewall_node.node(:text=>"Rules") {|rules_node|
            @snapshot.last[:firewall].rule_set.each {|id,from,to,services|
              if diff and not @snapshot[-2][:firewall].rule_set.keys.include?(id)
                color="#FF1919"
              else
                color="#DDDDDD"
              end
              rules_node.node(:text=>id.to_s,:cloud=>true, :cloud_color=>color) {|irule_node|
                # source
                irule_node.node(:text=>"source") {|source_node|
                  from.each{|source|
                    appearance=classify_firewall_zone(source)
                    source_node.node(:text=>source,:cloud=>true,:cloud_color=>appearance[:cloud_color],:icon=>appearance[:icons])
                    }  
                }
                # destination
                irule_node.node(:text=>"destination") {|destination_node|
                  to.each {|dest| 
                    appearance=classify_firewall_zone(dest)
                    destination_node.node(:text=>dest,:cloud=>true,:cloud_color=>appearance[:cloud_color],:icon=>appearance[:icons])
                    }
                }
                # services
                irule_node.node(:text=>"service") {|services_node|
                  services.each {|svc| services_node.node(:text=>svc)}
                }
              }
            }
        
          }
        }
  end
  
  def generate_mind_map(filename="./output/mm/scenario_start.mm", diff=false)
    @colors={}
    # loading the server colors
    File.open( './config/sources_colors.yml' ) { |yf| @colors=YAML::load( yf ) }
    # adding to them the user colors
    File.open( './config/users_colors.yml' ) { |yf| @colors.merge!(YAML::load( yf )) }
    take_snapshot
    p @snapshot.length if diff
    File.open_mm(filename,"w") {|mm|
      $spaces=0
      mm.node(:text=>@snapshot.last[:domain_name],:color=>"#7f5454", :font_size=>14,:font_bold=>true, :font_name=>"SansSerif") {|base_node|
        base_node.node(:text=>"Users",:position=>"right") {|users_base_node|
          @snapshot.last[:users].each {|user,groups|
            cloud_color="##{@colors[user].first}"
            cloud_color="#FF1919" if diff and not @snapshot[-2][:users].keys.include?(user)
            users_base_node.node(:text=>user,:icon=>["ksmiletris"],:cloud=>true,:cloud_color=>cloud_color) {|user_node| #)
              # write down groups
              user_node.node(:text=>"Groups") {|groups_node|
                groups.each {|group|
                  groups_node.node(:text=>group)
                }
              }
              # put down the email address:
              user_node.node(:text=>"Email") {|mail_node|
                mail_node.node(:text=>@snapshot.last[:servers][:email].email_directory[user])
              }
              # put down the machine the user is using
              user_node.node(:text=>"Computer") {|computer_node|
                computer_node.node(:text=>@snapshot.last[:userbase][user].host)
                computer_node.node(:text=>@snapshot.last[:userbase][user].ip)
                computer_node.node(:text=>"Local Accounts") {|local_accounts_node|
                  @snapshot.last[:userbase][user].localusers.keys.each {|luser|
                    if diff and not @snapshot[-2][:userbase][user].localusers.keys.include?(luser)
                      local_accounts_node.node(:text=>luser,:cloud=>true,:cloud_color=>"#FF1919")
                    else
                      local_accounts_node.node(:text=>luser)
                    end
                }
              }
        
            }
        
          }
          }    
        }
        #generate a list of the groups with the proper coloring
        base_node.node(:text=>"Groups",:position=>"right") {|group_base_node|
          #generating the list of the groups
          grouplist={}
          @snapshot.last[:users].each {|user,groups|
            groups.each {|grp|
             grouplist[grp]=grouplist[grp].to_a.push(user)
            }
          }
          grouplist.each {|group,members|
            group_base_node.node(:text=>group,:cloud_color=>group_color(group)) {|group_node|
              members.each {|member| group_node.node(:text=>member) }
            }
          }
        }
        # generate list of servers
        base_node.node(:text=>"Servers",:position=>"left") {|servers_base_node|
          @snapshot.last[:servers].each {|name,server|
            servers_base_node.node(:text=>server.host,:icon=>@colors[server.class.to_s].last,:cloud=>true,:cloud_color=>"##{@colors[server.class.to_s].first}") {|server_node| #
              server_node.node(:text=>"Object Name: #{name.to_s}")
              server_node.node(:text=>server.ip)
              server_node.node(:text=>server.class.to_s)
              # looking for local accounts
              if defined?(server.shadow) and server.shadow and not server.shadow.empty?
                server_node.node(:text=>"Local Accounts") {|shadow_node|
                  server.shadow.keys.each {|account|
                    shadow_node.node(:text=>account)
                  }
                }
              end
              # looking for local groups
              if defined?(server.etc_group) and server.etc_group and not server.etc_group.empty?
                server_node.node(:text=>"Local Groups") {|group_node|
                  server.etc_group.values.each {|etc_group|
                    group_node.node(:text=>etc_group)
                  }
                }
              end
              if server.class == Sources::Apache
                server_node.node(:text=>"sitemap") {|sitemap_node|
                  server.structure.each {|page|
                    sitemap_node.node(:text=>page)
                  }
                }
              elsif server.class == Sources::BluecoatSG
                server_node.node(:text=>"categories",:folded=>"true") {|categories_node|
                  server.categories.keys.each {|cat_key|
                    categories_node.node(:text=>cat_key)
                  }
                }
                  
                server_node.node(:text=>"blacklist") {|blacklist_node|
                  server.blacklist.each {|group,cat|
                    blacklist_node.node(:text=>group, :folded=>"true", :cloud_color=>group_color(group)){|bl_node|
                      cat.each{|c| bl_node.node(:text=>c)}                        
                    }
                  }
                }
              end
            }
          }      
        }
        
        #firewall settings
        draw_firewall(base_node,diff)
        
      }
    }
  end

